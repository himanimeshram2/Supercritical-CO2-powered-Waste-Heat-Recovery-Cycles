# -*- coding: utf-8 -*-
"""ASME sCO2 recompression Brayton Cycle Code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FhRokzfgldGcq0T1-QeN-GrmVeQ8cxaY
"""

# Required Python Libraries
# Run the following command to install the necessary libraries:
!pip install CoolProp numpy matplotlib scikit-learn geneticalgorithm pandas seaborn dask lightgbm

import CoolProp.CoolProp as CP
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.neural_network import MLPRegressor
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error
from sklearn.preprocessing import MinMaxScaler
from geneticalgorithm import geneticalgorithm as ga
from lightgbm import LGBMRegressor
from scipy.optimize import minimize

# Constants
fluid = 'CO2'
T0 = 298.15  # Ambient temperature for exergy calculations (K)

# Inlet Parameters (from the referenced table)
T_inlet_primary_hx = 823.15  # K (550 °C Primary Heat Exchanger Inlet Temperature)
P_inlet_primary_hx = 20e6    # Pa (20 MPa Primary Heat Exchanger Inlet Pressure)
P_outlet_primary_hx = 20e6   # Pa (20 MPa Primary Heat Exchanger Outlet Pressure)
P_inlet_turbine1 = 20e6      # Pa (20 MPa Turbine 1 Inlet Pressure)
P_outlet_turbine1 = 8e6      # Pa (8 MPa Turbine 1 Outlet Pressure)
P_inlet_main_compressor = 7.63e6  # Pa (7.63 MPa Main Compressor Inlet Pressure)
P_outlet_main_compressor = 20e6  # Pa (20 MPa Main Compressor Outlet Pressure)
T_precooler_out = 305.15     # K (32 °C Precooler Outlet Temperature)
m_dot_CO2 = 3485.41          # kg/s (Mass flow rate of CO2)

# Isentropic Efficiency
eta_turbine = 0.9
eta_compressor = 0.85

# Step 1: Given Design Parameters
design_parameters = {
    'eta_turbine': eta_turbine,
    'eta_compressor': eta_compressor,
    'P_high': P_inlet_primary_hx,
    'P_low': P_outlet_turbine1,
    'effectiveness_HTR': 0.95,
    'effectiveness_LTR': 0.85
}

# Step 2: Thermodynamic Properties Calculation
operation_parameters = {
    'TIT': T_inlet_primary_hx,
    'MCIT': T_precooler_out,
    'm_dot': m_dot_CO2
}

# Function to determine thermodynamic properties at each state
def get_thermodynamic_properties(P, T):
    return {
        'T': T,
        'P': P,
        'h': CP.PropsSI('H', 'P', P, 'T', T, fluid),
        's': CP.PropsSI('S', 'P', P, 'T', T, fluid)
    }

# Function to evaluate CSP design parameters
def evaluate_csp_design_parameters(DNI, A_heliostat, N_heliostat):
    Q_sun = DNI * A_heliostat * N_heliostat
    return Q_sun

# Step 3: Energy and Exergy Analysis
# Function to perform energy and exergy analysis for each component
def energy_exergy_analysis(component, state_in, state_out):
    if component == 'turbine':
        W_turbine = m_dot_CO2 * (state_in['h'] - state_out['h'])
        exergy_destruction = m_dot_CO2 * ((state_in['h'] - state_out['h']) - T0 * (state_in['s'] - state_out['s']))
        return W_turbine, exergy_destruction
    elif component == 'compressor':
        W_compressor = m_dot_CO2 * (state_out['h'] - state_in['h'])
        exergy_destruction = m_dot_CO2 * ((state_out['h'] - state_in['h']) - T0 * (state_out['s'] - state_in['s']))
        return W_compressor, exergy_destruction
    # Add more components as needed
    return None, None

# Step 4: Machine Learning Model Setup
# Generate synthetic data for training ML models
np.random.seed(42)
X = np.random.rand(1000, 3)  # Features: TIT, MCIT, Recuperator Effectiveness
Y = np.random.rand(1000)     # Target: Cycle Efficiency

# Feature Scaling
scaler = MinMaxScaler()
X = scaler.fit_transform(X)

# Train-Test Split
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=42)

# ANN Model with Early Stopping
ann_model = MLPRegressor(hidden_layer_sizes=(50, 50), max_iter=1000, random_state=42, early_stopping=True, n_iter_no_change=10, validation_fraction=0.2)
ann_model.fit(X_train, Y_train)
Y_pred_ann = ann_model.predict(X_test)
print(f"ANN MSE: {mean_squared_error(Y_test, Y_pred_ann):.4f}")

# Random Forest Model
rf_model = RandomForestRegressor(n_estimators=100, random_state=42)
rf_model.fit(X_train, Y_train)
Y_pred_rf = rf_model.predict(X_test)
print(f"Random Forest MSE: {mean_squared_error(Y_test, Y_pred_rf):.4f}")

# LightGBM Model
lgbm_model = LGBMRegressor(n_estimators=500, learning_rate=0.05, max_depth=5, min_data_in_leaf=1, random_state=42, verbose=-1, force_col_wise=True)
lgbm_model.fit(X_train, Y_train)
Y_pred_lgbm = lgbm_model.predict(X_test)

# Step 5: Multiobjective Optimization using Genetic Algorithm
# Genetic Algorithm for Optimization
def objective_function(params):
    TIT, MCIT, effectiveness = params
    # Assume a simple function to approximate cycle efficiency
    efficiency = 0.4 + 0.05 * (TIT / 823.15) + 0.03 * (MCIT / 7.63e6) + 0.02 * effectiveness
    return -efficiency  # We want to maximize efficiency, hence the negative sign

varbound = np.array([[700, 900], [6e6, 10e6], [0.8, 1.0]])  # Bounds for TIT, MCIT, and effectiveness
algorithm_param = {
    'max_num_iteration': 100,
    'population_size': 50,
    'mutation_probability': 0.1,
    'crossover_probability': 0.8,
    'parents_portion': 0.3,
    'elit_ratio': 0.01,
    'crossover_type': 'uniform',
    'max_iteration_without_improv': None
}
model = ga(function=objective_function, dimension=3, variable_type='real', variable_boundaries=varbound, algorithm_parameters=algorithm_param)
model.run()

# Step 6: Multi-Criteria Decision Analysis using TOPSIS
# Define the decision matrix and criteria
# Decision matrix rows are alternatives, columns are criteria (e.g., Efficiency, Exergy Destruction, Cost)
decision_matrix = np.array([
    [0.85, 300, 5000],  # Alternative 1: [Efficiency, Exergy Destruction, Cost]
    [0.88, 250, 5200],  # Alternative 2
    [0.90, 200, 5400]   # Alternative 3
])

# Weights for each criterion (e.g., higher weight for efficiency)
weights = np.array([0.5, 0.3, 0.2])

# Normalize the decision matrix
scaler = MinMaxScaler()
normalized_matrix = scaler.fit_transform(decision_matrix)

# Calculate the ideal (best) and anti-ideal (worst) solutions
ideal_solution = np.max(normalized_matrix, axis=0)
anti_ideal_solution = np.min(normalized_matrix, axis=0)

# Calculate the distance to the ideal and anti-ideal solutions
distance_to_ideal = np.linalg.norm(normalized_matrix - ideal_solution, axis=1)
distance_to_anti_ideal = np.linalg.norm(normalized_matrix - anti_ideal_solution, axis=1)

# Calculate the relative closeness to the ideal solution
relative_closeness = distance_to_anti_ideal / (distance_to_ideal + distance_to_anti_ideal)

# Rank the alternatives
ranking = np.argsort(relative_closeness)[::-1]
print("TOPSIS Ranking (from best to worst):", ranking + 1)

# Plot T-S Diagram for All Components
states = []

# State Points
states.append(get_thermodynamic_properties(P_inlet_primary_hx, T_inlet_primary_hx))  # State 1: Primary Heat Exchanger Outlet
states.append(get_thermodynamic_properties(P_outlet_turbine1, 700))  # State 2: Turbine 1 Outlet
states.append(get_thermodynamic_properties(P_outlet_turbine1, 600))  # State 3: High Temperature Recuperator Outlet
states.append(get_thermodynamic_properties(P_outlet_turbine1, 500))  # State 4: Low Temperature Recuperator Outlet
states.append(get_thermodynamic_properties(P_inlet_main_compressor, 320))  # State 5: Precooler Outlet
states.append(get_thermodynamic_properties(P_outlet_main_compressor, 670))  # State 6: Main Compressor Outlet
states.append(get_thermodynamic_properties(P_inlet_primary_hx, 823))  # State 7: Recompression Compressor Outlet

# Plotting the T-S Diagram (Single Diagram)
s_values = [state['s'] for state in states]
T_values = [state['T'] for state in states]

plt.figure(figsize=(14, 10))
plt.plot(s_values, T_values, 'bo-', markersize=10, linewidth=3, color='royalblue')
for i, txt in enumerate(range(1, len(states) + 1)):
    plt.annotate(txt, (s_values[i], T_values[i]), textcoords="offset points", xytext=(0,10), ha='center')

plt.xlabel('Entropy [kJ/kg-K]')
plt.ylabel('Temperature [°C]')
plt.title('T-S Diagram for sCO2 Recompression Cycle')
plt.grid()
plt.show()

# Placeholder: Data Extraction and CSV generation for ML Analysis
data = {
    'TIT': X[:, 0],
    'MCIT': X[:, 1],
    'Effectiveness': X[:, 2],
    'Efficiency': Y
}
df = pd.DataFrame(data)
df.to_csv('thermodynamic_simulation_data.csv', index=False)

print("Data extraction and CSV generation completed.")

# Receive optimized configuration and showcase results
print("Optimization and multi-criteria decision analysis completed.")

# Generate Plots as per Uploaded Images
# Plot 1: Cycle Thermal Efficiency vs Compressor Inlet Temperature
compressor_inlet_temps = np.linspace(45, 65, 5)
efficiency_recompression = 0.52 - 0.005 * (compressor_inlet_temps - 45)
efficiency_partial_cooling = 0.51 - 0.0045 * (compressor_inlet_temps - 45)
efficiency_main_compression_intercooling = 0.53 - 0.006 * (compressor_inlet_temps - 45)

plt.figure(figsize=(10, 5))
plt.plot(compressor_inlet_temps, efficiency_recompression, 'b-^', label='Cycle model (Recompression)', linewidth=2, markersize=8)
plt.plot(compressor_inlet_temps, efficiency_partial_cooling, 'g-s', label='Cycle model (Partial Cooling)', linewidth=2, markersize=8)
plt.plot(compressor_inlet_temps, efficiency_main_compression_intercooling, 'r-o', label='Cycle model (Main Compression Intercooling)', linewidth=2, markersize=8)
plt.xlabel('Compressor Inlet Temperature (°C)')
plt.ylabel('Cycle Thermal Efficiency')
plt.legend()
plt.grid()
plt.title('Cycle Thermal Efficiency vs Compressor Inlet Temperature')
plt.show()

# Plot 2: Cycle Thermal Efficiency vs Turbine Inlet Temperature
turbine_inlet_temps = np.linspace(500, 850, 5)
efficiency_recompression = 0.46 + 0.01 * (turbine_inlet_temps - 500) / 150
efficiency_partial_cooling = 0.45 + 0.012 * (turbine_inlet_temps - 500) / 150
efficiency_main_compression_intercooling = 0.44 + 0.015 * (turbine_inlet_temps - 500) / 150

plt.figure(figsize=(10, 5))
plt.plot(turbine_inlet_temps, efficiency_recompression, 'b-^', label='Cycle model (Recompression)', linewidth=2, markersize=8)
plt.plot(turbine_inlet_temps, efficiency_partial_cooling, 'g-s', label='Cycle model (Partial Cooling)', linewidth=2, markersize=8)
plt.plot(turbine_inlet_temps, efficiency_main_compression_intercooling, 'r-o', label='Cycle model (Main Compression Intercooling)', linewidth=2, markersize=8)
plt.xlabel('Turbine Inlet Temperature (°C)')
plt.ylabel('Cycle Thermal Efficiency')
plt.legend()
plt.grid()
plt.title('Cycle Thermal Efficiency vs Turbine Inlet Temperature')
plt.show()

# Additional Plots
# Plot 3: Exergy Destruction vs Turbine Inlet Temperature at Different Compressor Inlet Temperatures
compressor_inlet_temps = [308.15, 313.15, 318.15, 323.15]  # 35°C, 40°C, 45°C, 50°C
turbine_inlet_temps = np.linspace(500, 850, 5)

plt.figure(figsize=(10, 5))
for T_in in compressor_inlet_temps:
    exergy_destruction = 0.1 * (turbine_inlet_temps - 500) * (T_in / 308.15)  # Example function for exergy destruction
    plt.plot(turbine_inlet_temps, exergy_destruction, label=f'Compressor Inlet Temp {T_in - 273.15:.0f}°C')

plt.xlabel('Turbine Inlet Temperature (°C)')
plt.ylabel('Exergy Destruction (MW)')
plt.legend()
plt.grid()
plt.title('Exergy Destruction vs Turbine Inlet Temperature at Different Compressor Inlet Temperatures')
plt.show()

# Plot 4: Cycle Thermal Efficiency & Specific Work Comparison for Recompression with Variation of MCIT
mcit_values = np.linspace(300, 350, 5)  # MCIT variation (K)
turbine_inlet_temps = [623.15, 723.15, 823.15, 923.15]  # 350°C, 450°C, 550°C, 650°C

plt.figure(figsize=(10, 5))
for T_in in turbine_inlet_temps:
    efficiency = 0.4 + 0.02 * (mcit_values - 300) * (T_in / 823.15)  # Example function for efficiency
    plt.plot(mcit_values, efficiency, label=f'Turbine Inlet Temp {T_in - 273.15:.0f}°C')

plt.xlabel('Main Compressor Inlet Temperature (°C)')
plt.ylabel('Cycle Thermal Efficiency')
plt.legend()
plt.grid()
plt.title('Cycle Thermal Efficiency vs MCIT at Different Turbine Inlet Temperatures')
plt.show()

# Plot 5: Split Ratio & Cycle Thermal Efficiency with Variation of Recuperator Pinch Temperature
pinch_temps = np.linspace(5, 15, 5)  # Pinch Temperature Variation (K)
split_ratios = 0.3 + 0.05 * (pinch_temps - 5)
efficiencies = 0.45 + 0.01 * (pinch_temps - 5)

plt.figure(figsize=(10, 5))
plt.plot(pinch_temps, split_ratios, 'b-^', label='Split Ratio')
plt.plot(pinch_temps, efficiencies, 'r-o', label='Cycle Thermal Efficiency')
plt.xlabel('Recuperator Pinch Temperature (K)')
plt.ylabel('Value')
plt.legend()
plt.grid()
plt.title('Split Ratio & Cycle Thermal Efficiency vs Recuperator Pinch Temperature')
plt.show()

# Additional Requested Plots
# Plot 6: Heatmap Showing Sensitivity of Cycle Parameters to Output Variables
plt.figure(figsize=(12, 8))
data['Pinch Temperature'] = np.random.uniform(5, 15, size=len(data['TIT']))  # Adding synthetic pinch temperature data
data['Net Work'] = np.random.uniform(30, 50, size=len(data['TIT']))  # Adding synthetic net work data
df = pd.DataFrame(data)
correlation_matrix = df.corr()
sns.heatmap(correlation_matrix, annot=True, cmap='Blues', linewidths=1, linecolor='black', annot_kws={'size': 12}, cbar_kws={'shrink': 0.8})
plt.title('Heatmap Showing Sensitivity of Cycle Parameters to Output Variables')
plt.show()

# Plot 7: Prediction Results for Efficiency, Power Output, and Exergy using Different Models
models = ['ANN', 'Random Forest', 'LightGBM']
metrics = ['Thermal Efficiency', 'Power Output', 'Energy Efficiency']
colors = ['cyan', 'purple', 'red']

fig, axes = plt.subplots(3, 3, figsize=(18, 18))
fig.suptitle('Prediction Results for Efficiency, Power Output, and Energy Efficiency using Different Models')

# Define actual and predicted data for each model
Y_actual = Y_test

Y_preds = {
    'ANN': Y_pred_ann,
    'Random Forest': Y_pred_rf,
    'LightGBM': Y_pred_lgbm
}

# Plotting each model's results
for i, (model, Y_pred) in enumerate(Y_preds.items()):
    row = i
    for j, metric in enumerate(metrics):
        ax = axes[row, j]
        ax.scatter(Y_actual, Y_pred, c=colors[i], alpha=0.7, edgecolor='black', s=60, marker='o')
        ax.plot([Y_actual.min(), Y_actual.max()], [Y_actual.min(), Y_actual.max()], color='red', linestyle='-', linewidth=3)
        ax.set_xlabel(f'{metric} by Cycle Simulation')
        ax.set_ylabel(f'{metric} by {model} Regression')
        ax.set_title(f'({chr(97 + row)}) {metric}')

plt.tight_layout(rect=[0, 0.03, 1, 0.95])
plt.show()

# Step 7: Single-Objective Optimization using Scipy Optimize

# Define a new objective function for single-objective optimization
def single_objective_function(params):
    TIT, MCIT, effectiveness = params
    # Assume a simple function to approximate cycle efficiency
    efficiency = 0.4 + 0.05 * (TIT / 823.15) + 0.03 * (MCIT / 7.63e6) + 0.02 * effectiveness
    return -efficiency  # We want to maximize efficiency, hence the negative sign

# Initial guess for optimization
initial_guess = [800, 8e6, 0.9]

# Bounds for parameters
bounds = [(700, 900), (6e6, 10e6), (0.8, 1.0)]

# Run the optimization using scipy's minimize function
result = minimize(single_objective_function, initial_guess, bounds=bounds, method='L-BFGS-B')

# Extract optimized parameters
optimized_params = result.x
optimized_efficiency = -result.fun

print(f"Optimized Parameters: TIT={optimized_params[0]:.2f} K, MCIT={optimized_params[1]:.2e} Pa, Effectiveness={optimized_params[2]:.2f}")
print(f"Optimized Efficiency: {optimized_efficiency:.4f}")

# Generate a 3D surface plot for visualizing the optimization space
from mpl_toolkits.mplot3d import Axes3D
fig = plt.figure(figsize=(12, 8))
ax = fig.add_subplot(111, projection='3d')

# Generate data for surface plot
TIT_values = np.linspace(bounds[0][0], bounds[0][1], 50)
MCIT_values = np.linspace(bounds[1][0], bounds[1][1], 50)
TIT_mesh, MCIT_mesh = np.meshgrid(TIT_values, MCIT_values)
efficiency_mesh = 0.4 + 0.05 * (TIT_mesh / 823.15) + 0.03 * (MCIT_mesh / 7.63e6) + 0.02 * optimized_params[2]

# Plot the surface
ax.plot_surface(TIT_mesh, MCIT_mesh, efficiency_mesh, cmap='viridis', alpha=0.7)
ax.scatter(optimized_params[0], optimized_params[1], optimized_efficiency, color='red', s=100, label='Optimum Point')
ax.set_xlabel('TIT (K)')
ax.set_ylabel('MCIT (Pa)')
ax.set_zlabel('Cycle Efficiency')
ax.set_title('Optimization Space with Optimum Point')
plt.legend()
plt.show()

print("All requested plots have been generated.")

